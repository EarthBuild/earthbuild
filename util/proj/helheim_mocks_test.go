// Code generated by git.sr.ht/~nelsam/hel. DO NOT EDIT.
//
// This file contains mocks generated by hel. Do not edit this code by
// hand unless you *really* know what you're doing. Expect any changes
// made manually to be overwritten the next time hel regenerates this
// file.

package proj_test

import (
	"context"
	"git.sr.ht/~nelsam/hel/pkg/pers"
	"git.sr.ht/~nelsam/hel/vegr"
	"github.com/EarthBuild/earthbuild/util/proj"
	"io"
	"io/fs"
	"time"
)

var (
	_ = vegr.EnforceVersion(7 - vegr.MinVersion)
	_ = vegr.EnforceVersion(vegr.MaxVersion - 7)
)

type mockFS_Open_In struct {
	Name string
}

func (mockFS_Open_In) Variadic() bool {
	return false
}

type mockFS_Open_Out struct {
	Panic_ any
	Ret0   fs.File
	Ret1   error
}
type mockFS_Open struct {
	vegr.Method[mockFS_Open_In, mockFS_Open_Out]
}
type mockFS_Stat_In struct {
	Name string
}

func (mockFS_Stat_In) Variadic() bool {
	return false
}

type mockFS_Stat_Out struct {
	Panic_ any
	Ret0   fs.FileInfo
	Ret1   error
}
type mockFS_Stat struct {
	vegr.Method[mockFS_Stat_In, mockFS_Stat_Out]
}
type mockFS struct {
	prefs  vegr.Prefs
	method struct {
		Open mockFS_Open
		Stat mockFS_Stat
	}
}

func newMockFS(cst pers.Constructor) *mockFS {
	m := &mockFS{prefs: vegr.MakePrefs(cst)}
	m.method.Open.Method = vegr.NewMethod[mockFS_Open_In, mockFS_Open_Out]("mockFS", "Open", 100, vegr.WithPrefs(m.prefs))
	m.method.Stat.Method = vegr.NewMethod[mockFS_Stat_In, mockFS_Stat_Out]("mockFS", "Stat", 100, vegr.WithPrefs(m.prefs))
	return m
}
func (m *mockFS) Open(name string) (ret0 fs.File, ret1 error) {
	m.prefs.T().Helper()
	vegr.Perform(m.prefs.T(), m.method.Open, mockFS_Open_In{Name: name}, &ret0, &ret1)
	return ret0, ret1
}
func (m *mockFS) Stat(name string) (ret0 fs.FileInfo, ret1 error) {
	m.prefs.T().Helper()
	vegr.Perform(m.prefs.T(), m.method.Stat, mockFS_Stat_In{Name: name}, &ret0, &ret1)
	return ret0, ret1
}

type mockFile_Stat_In struct {
}

func (mockFile_Stat_In) Variadic() bool {
	return false
}

type mockFile_Stat_Out struct {
	Panic_ any
	Ret0   fs.FileInfo
	Ret1   error
}
type mockFile_Stat struct {
	vegr.Method[mockFile_Stat_In, mockFile_Stat_Out]
}
type mockFile_Read_In struct {
	Arg0 []byte
}

func (mockFile_Read_In) Variadic() bool {
	return false
}

type mockFile_Read_Out struct {
	Panic_ any
	Ret0   int
	Ret1   error
}
type mockFile_Read struct {
	vegr.Method[mockFile_Read_In, mockFile_Read_Out]
}
type mockFile_Close_In struct {
}

func (mockFile_Close_In) Variadic() bool {
	return false
}

type mockFile_Close_Out struct {
	Panic_ any
	Ret0   error
}
type mockFile_Close struct {
	vegr.Method[mockFile_Close_In, mockFile_Close_Out]
}
type mockFile struct {
	prefs  vegr.Prefs
	method struct {
		Stat  mockFile_Stat
		Read  mockFile_Read
		Close mockFile_Close
	}
}

func newMockFile(cst pers.Constructor) *mockFile {
	m := &mockFile{prefs: vegr.MakePrefs(cst)}
	m.method.Stat.Method = vegr.NewMethod[mockFile_Stat_In, mockFile_Stat_Out]("mockFile", "Stat", 100, vegr.WithPrefs(m.prefs))
	m.method.Read.Method = vegr.NewMethod[mockFile_Read_In, mockFile_Read_Out]("mockFile", "Read", 100, vegr.WithPrefs(m.prefs))
	m.method.Close.Method = vegr.NewMethod[mockFile_Close_In, mockFile_Close_Out]("mockFile", "Close", 100, vegr.WithPrefs(m.prefs))
	return m
}
func (m *mockFile) Stat() (ret0 fs.FileInfo, ret1 error) {
	m.prefs.T().Helper()
	vegr.Perform(m.prefs.T(), m.method.Stat, mockFile_Stat_In{}, &ret0, &ret1)
	return ret0, ret1
}
func (m *mockFile) Read(arg0 []byte) (ret0 int, ret1 error) {
	m.prefs.T().Helper()
	vegr.Perform(m.prefs.T(), m.method.Read, mockFile_Read_In{Arg0: arg0}, &ret0, &ret1)
	return ret0, ret1
}
func (m *mockFile) Close() (ret0 error) {
	m.prefs.T().Helper()
	vegr.Perform(m.prefs.T(), m.method.Close, mockFile_Close_In{}, &ret0)
	return ret0
}

type mockFileInfo_Name_In struct {
}

func (mockFileInfo_Name_In) Variadic() bool {
	return false
}

type mockFileInfo_Name_Out struct {
	Panic_ any
	Ret0   string
}
type mockFileInfo_Name struct {
	vegr.Method[mockFileInfo_Name_In, mockFileInfo_Name_Out]
}
type mockFileInfo_Size_In struct {
}

func (mockFileInfo_Size_In) Variadic() bool {
	return false
}

type mockFileInfo_Size_Out struct {
	Panic_ any
	Ret0   int64
}
type mockFileInfo_Size struct {
	vegr.Method[mockFileInfo_Size_In, mockFileInfo_Size_Out]
}
type mockFileInfo_Mode_In struct {
}

func (mockFileInfo_Mode_In) Variadic() bool {
	return false
}

type mockFileInfo_Mode_Out struct {
	Panic_ any
	Ret0   fs.FileMode
}
type mockFileInfo_Mode struct {
	vegr.Method[mockFileInfo_Mode_In, mockFileInfo_Mode_Out]
}
type mockFileInfo_ModTime_In struct {
}

func (mockFileInfo_ModTime_In) Variadic() bool {
	return false
}

type mockFileInfo_ModTime_Out struct {
	Panic_ any
	Ret0   time.Time
}
type mockFileInfo_ModTime struct {
	vegr.Method[mockFileInfo_ModTime_In, mockFileInfo_ModTime_Out]
}
type mockFileInfo_IsDir_In struct {
}

func (mockFileInfo_IsDir_In) Variadic() bool {
	return false
}

type mockFileInfo_IsDir_Out struct {
	Panic_ any
	Ret0   bool
}
type mockFileInfo_IsDir struct {
	vegr.Method[mockFileInfo_IsDir_In, mockFileInfo_IsDir_Out]
}
type mockFileInfo_Sys_In struct {
}

func (mockFileInfo_Sys_In) Variadic() bool {
	return false
}

type mockFileInfo_Sys_Out struct {
	Panic_ any
	Ret0   any
}
type mockFileInfo_Sys struct {
	vegr.Method[mockFileInfo_Sys_In, mockFileInfo_Sys_Out]
}
type mockFileInfo struct {
	prefs  vegr.Prefs
	method struct {
		Name    mockFileInfo_Name
		Size    mockFileInfo_Size
		Mode    mockFileInfo_Mode
		ModTime mockFileInfo_ModTime
		IsDir   mockFileInfo_IsDir
		Sys     mockFileInfo_Sys
	}
}

func newMockFileInfo(cst pers.Constructor) *mockFileInfo {
	m := &mockFileInfo{prefs: vegr.MakePrefs(cst)}
	m.method.Name.Method = vegr.NewMethod[mockFileInfo_Name_In, mockFileInfo_Name_Out]("mockFileInfo", "Name", 100, vegr.WithPrefs(m.prefs))
	m.method.Size.Method = vegr.NewMethod[mockFileInfo_Size_In, mockFileInfo_Size_Out]("mockFileInfo", "Size", 100, vegr.WithPrefs(m.prefs))
	m.method.Mode.Method = vegr.NewMethod[mockFileInfo_Mode_In, mockFileInfo_Mode_Out]("mockFileInfo", "Mode", 100, vegr.WithPrefs(m.prefs))
	m.method.ModTime.Method = vegr.NewMethod[mockFileInfo_ModTime_In, mockFileInfo_ModTime_Out]("mockFileInfo", "ModTime", 100, vegr.WithPrefs(m.prefs))
	m.method.IsDir.Method = vegr.NewMethod[mockFileInfo_IsDir_In, mockFileInfo_IsDir_Out]("mockFileInfo", "IsDir", 100, vegr.WithPrefs(m.prefs))
	m.method.Sys.Method = vegr.NewMethod[mockFileInfo_Sys_In, mockFileInfo_Sys_Out]("mockFileInfo", "Sys", 100, vegr.WithPrefs(m.prefs))
	return m
}
func (m *mockFileInfo) Name() (ret0 string) {
	m.prefs.T().Helper()
	vegr.Perform(m.prefs.T(), m.method.Name, mockFileInfo_Name_In{}, &ret0)
	return ret0
}
func (m *mockFileInfo) Size() (ret0 int64) {
	m.prefs.T().Helper()
	vegr.Perform(m.prefs.T(), m.method.Size, mockFileInfo_Size_In{}, &ret0)
	return ret0
}
func (m *mockFileInfo) Mode() (ret0 fs.FileMode) {
	m.prefs.T().Helper()
	vegr.Perform(m.prefs.T(), m.method.Mode, mockFileInfo_Mode_In{}, &ret0)
	return ret0
}
func (m *mockFileInfo) ModTime() (ret0 time.Time) {
	m.prefs.T().Helper()
	vegr.Perform(m.prefs.T(), m.method.ModTime, mockFileInfo_ModTime_In{}, &ret0)
	return ret0
}
func (m *mockFileInfo) IsDir() (ret0 bool) {
	m.prefs.T().Helper()
	vegr.Perform(m.prefs.T(), m.method.IsDir, mockFileInfo_IsDir_In{}, &ret0)
	return ret0
}
func (m *mockFileInfo) Sys() (ret0 any) {
	m.prefs.T().Helper()
	vegr.Perform(m.prefs.T(), m.method.Sys, mockFileInfo_Sys_In{}, &ret0)
	return ret0
}

type mockExecer_Command_In struct {
	Name string
	Args []string
}

func (mockExecer_Command_In) Variadic() bool {
	return true
}

type mockExecer_Command_Out struct {
	Panic_ any
	Ret0   proj.Cmd
}
type mockExecer_Command struct {
	vegr.Method[mockExecer_Command_In, mockExecer_Command_Out]
}
type mockExecer struct {
	prefs  vegr.Prefs
	method struct {
		Command mockExecer_Command
	}
}

func newMockExecer(cst pers.Constructor) *mockExecer {
	m := &mockExecer{prefs: vegr.MakePrefs(cst)}
	m.method.Command.Method = vegr.NewMethod[mockExecer_Command_In, mockExecer_Command_Out]("mockExecer", "Command", 100, vegr.WithPrefs(m.prefs))
	return m
}
func (m *mockExecer) Command(name string, args ...string) (ret0 proj.Cmd) {
	m.prefs.T().Helper()
	vegr.Perform(m.prefs.T(), m.method.Command, mockExecer_Command_In{Name: name, Args: args}, &ret0)
	return ret0
}

type mockCmd_Run_In struct {
	Ctx context.Context
}

func (mockCmd_Run_In) Variadic() bool {
	return false
}

type mockCmd_Run_Out struct {
	Panic_         any
	Stdout, Stderr io.Reader
	Ret1           error
}
type mockCmd_Run struct {
	vegr.Method[mockCmd_Run_In, mockCmd_Run_Out]
}
type mockCmd struct {
	prefs  vegr.Prefs
	method struct {
		Run mockCmd_Run
	}
}

func newMockCmd(cst pers.Constructor) *mockCmd {
	m := &mockCmd{prefs: vegr.MakePrefs(cst)}
	m.method.Run.Method = vegr.NewMethod[mockCmd_Run_In, mockCmd_Run_Out]("mockCmd", "Run", 100, vegr.WithPrefs(m.prefs))
	return m
}
func (m *mockCmd) Run(ctx context.Context) (stdout, stderr io.Reader, ret1 error) {
	m.prefs.T().Helper()
	vegr.Perform(m.prefs.T(), m.method.Run, mockCmd_Run_In{Ctx: ctx}, &stdout, &stderr, &ret1)
	return stdout, stderr, ret1
}

type mockContext_Deadline_In struct {
}

func (mockContext_Deadline_In) Variadic() bool {
	return false
}

type mockContext_Deadline_Out struct {
	Panic_   any
	Deadline time.Time
	Ok       bool
}
type mockContext_Deadline struct {
	vegr.Method[mockContext_Deadline_In, mockContext_Deadline_Out]
}
type mockContext_Done_In struct {
}

func (mockContext_Done_In) Variadic() bool {
	return false
}

type mockContext_Done_Out struct {
	Panic_ any
	Ret0   <-chan struct{}
}
type mockContext_Done struct {
	vegr.Method[mockContext_Done_In, mockContext_Done_Out]
}
type mockContext_Err_In struct {
}

func (mockContext_Err_In) Variadic() bool {
	return false
}

type mockContext_Err_Out struct {
	Panic_ any
	Ret0   error
}
type mockContext_Err struct {
	vegr.Method[mockContext_Err_In, mockContext_Err_Out]
}
type mockContext_Value_In struct {
	Key any
}

func (mockContext_Value_In) Variadic() bool {
	return false
}

type mockContext_Value_Out struct {
	Panic_ any
	Ret0   any
}
type mockContext_Value struct {
	vegr.Method[mockContext_Value_In, mockContext_Value_Out]
}
type mockContext struct {
	prefs  vegr.Prefs
	method struct {
		Deadline mockContext_Deadline
		Done     mockContext_Done
		Err      mockContext_Err
		Value    mockContext_Value
	}
}

func newMockContext(cst pers.Constructor) *mockContext {
	m := &mockContext{prefs: vegr.MakePrefs(cst)}
	m.method.Deadline.Method = vegr.NewMethod[mockContext_Deadline_In, mockContext_Deadline_Out]("mockContext", "Deadline", 100, vegr.WithPrefs(m.prefs))
	m.method.Done.Method = vegr.NewMethod[mockContext_Done_In, mockContext_Done_Out]("mockContext", "Done", 100, vegr.WithPrefs(m.prefs))
	m.method.Err.Method = vegr.NewMethod[mockContext_Err_In, mockContext_Err_Out]("mockContext", "Err", 100, vegr.WithPrefs(m.prefs))
	m.method.Value.Method = vegr.NewMethod[mockContext_Value_In, mockContext_Value_Out]("mockContext", "Value", 100, vegr.WithPrefs(m.prefs))
	return m
}
func (m *mockContext) Deadline() (deadline time.Time, ok bool) {
	m.prefs.T().Helper()
	vegr.Perform(m.prefs.T(), m.method.Deadline, mockContext_Deadline_In{}, &deadline, &ok)
	return deadline, ok
}
func (m *mockContext) Done() (ret0 <-chan struct{}) {
	m.prefs.T().Helper()
	vegr.Perform(m.prefs.T(), m.method.Done, mockContext_Done_In{}, &ret0)
	return ret0
}
func (m *mockContext) Err() (ret0 error) {
	m.prefs.T().Helper()
	vegr.Perform(m.prefs.T(), m.method.Err, mockContext_Err_In{}, &ret0)
	return ret0
}
func (m *mockContext) Value(key any) (ret0 any) {
	m.prefs.T().Helper()
	vegr.Perform(m.prefs.T(), m.method.Value, mockContext_Value_In{Key: key}, &ret0)
	return ret0
}

type mockReader_Read_In struct {
	P []byte
}

func (mockReader_Read_In) Variadic() bool {
	return false
}

type mockReader_Read_Out struct {
	Panic_ any
	N      int
	Err    error
}
type mockReader_Read struct {
	vegr.Method[mockReader_Read_In, mockReader_Read_Out]
}
type mockReader struct {
	prefs  vegr.Prefs
	method struct {
		Read mockReader_Read
	}
}

func newMockReader(cst pers.Constructor) *mockReader {
	m := &mockReader{prefs: vegr.MakePrefs(cst)}
	m.method.Read.Method = vegr.NewMethod[mockReader_Read_In, mockReader_Read_Out]("mockReader", "Read", 100, vegr.WithPrefs(m.prefs))
	return m
}
func (m *mockReader) Read(p []byte) (n int, err error) {
	m.prefs.T().Helper()
	vegr.Perform(m.prefs.T(), m.method.Read, mockReader_Read_In{P: p}, &n, &err)
	return n, err
}

type mockWriter_Write_In struct {
	P []byte
}

func (mockWriter_Write_In) Variadic() bool {
	return false
}

type mockWriter_Write_Out struct {
	Panic_ any
	N      int
	Err    error
}
type mockWriter_Write struct {
	vegr.Method[mockWriter_Write_In, mockWriter_Write_Out]
}
type mockWriter struct {
	prefs  vegr.Prefs
	method struct {
		Write mockWriter_Write
	}
}

func newMockWriter(cst pers.Constructor) *mockWriter {
	m := &mockWriter{prefs: vegr.MakePrefs(cst)}
	m.method.Write.Method = vegr.NewMethod[mockWriter_Write_In, mockWriter_Write_Out]("mockWriter", "Write", 100, vegr.WithPrefs(m.prefs))
	return m
}
func (m *mockWriter) Write(p []byte) (n int, err error) {
	m.prefs.T().Helper()
	vegr.Perform(m.prefs.T(), m.method.Write, mockWriter_Write_In{P: p}, &n, &err)
	return n, err
}
